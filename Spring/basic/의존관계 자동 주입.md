
### 의존관계 주입 4가지

1. 생성자 주입
2. 수정자 주입( setter 주입 )
3. 필드 주입
4. 일반 메서드 주입

// 좋은 코드란 한계점. 제약이 있어야 한다.

### 생성자 주입
- 이름 그대로 생성자를 통해서 의존 관계를 주입 받는 방법.
- 특징
	- 생성자 호출 시점에 딱 1번만 호출됨.
	- ==불변, 필수== 의존 관계에 사용
- 중요!!!!! 생성자가 딱 1개 있으면 @Autowired를 생략해도 자동 주입이 된다. 물론 스프링 빈 한정.


### 수정자 주입
- setter 라 불리는 필드의 값을 변경하는 수정자 메서드를 통해서 의존관계를 주입하는 방법이다.
- 특징
	- ==선택, 변경== 가능성이 있는 의존관계에 사용
	- 자바빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법이다.

![[Pasted image 20221220234518.png]]

	!! @Autowired 의 기본 동작은 주입할 대상이 없으면 오류 발생. 주입할 대상이 없어도 동작하게하려면 @Autowired(required = false)로 지정하면 된다

### 필드 주입
- 이름 그대로 필드에 바로 주입
- 특징
	- 코드가 간결해서 많은 개발자들을 유혹하지만, 외부에서 변경이 불가능해서 테스트 하기 힘들다는 단점
	- DI 프레임 워크가 없으면 아무것도 할 수 없다.
	- ==이러한 이유로 사용하지 말자!!==
		- 애플리케이션의 실제코드와 관계 없는 테스트코드
		- 스프링 설정을 목적으로 하는 @COnfiguration 같은 곳에서만 특별한 용도로 사용

![[Pasted image 20221221160835.png]]

![[Pasted image 20221221160857.png]]

	<필드 주입은 인텔리제이 에서도 추천하지 않는 코드>


### 일반 메서드 주입
- 일반 메스드를 통해서 주입 받을 수 있다.
- 특징
	- 한번에 여러 필드를 주입 받을 수 있다.
	- 일반적으로 잘 사용하지 않음
	- 


### 옵션 처리
- 주입할 스프링 빈이 없어도 동작해야 할 때가 있다.
- @Autowired만 사용하면 required 옵션의 기본값이 true 로 되어있어서 자동 주입 대상이 없으면 오류 발생

### 자동 주입 대상을 옵션으로 처리하는 방법 3 가지

- @AutoWired(required=false) : 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출 안됨
- org.springframework.lang.@Nullable : 자동 주입할 대상이 없으면 null이 입력된다.
- Optional<> :  자동 주입할 대상이 없으면 Optional.empty가 입력된다.

![[Pasted image 20221221163706.png]]

#### !!! Member 객체는 스프링 빈이 아님.
setNoBean1() 은 @Autowired(required  = false ) 이므로 호출 자체가 안된다.


## 그러므로 생성자 주입을 사용하자!

장점
1. 불변
	- 대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없다. 오히려 대부분의 의존관계는 애플리케이션 종료 전까지 변하면 안된다.
	- 수정자 주입을 사용하면 ,set 메서드를 pulbic으로 열어두어야 한다.
	- 실수로 변경할 수도 있고, 변경하면 안되는 메서드를 열어두는 것은 좋은 설계 방법이 아니다.
	- 생성자 주입은 객첼를 생성할 때 딱 1번만 호출되므로 이후에 호출되는 일이 없다. 따라서 불변하게 설계할수 있다.
2. 누락
	- 생성자 주입을 사용하면 주입 데이터를 누락 했을 때 컴파일 오류가 발생한다.
3. final 키워드
	- 생성자 주입을 사용하면 필드에 final 키워드를 사용할 수 있다. 그래서 생성자에서 혹시라도 값이 설정되지 않는 오류를 컴파일 시점에서 막아준다.



## 조회 빈이 2개 이상일때 문제

@Autowired 는 타입(Type) 으로 조회를 한다.
타입으로 조회하기 때문에 ac.getBean(class) 와 유사하게 동작한다. 타입으로 조회하면 선택된 빈이 2개 이상일 때 문제가 발생한다.(부모 타입으로 조회시 자식이 전부 조회되기 떄문)

해결 방법 3가지
1. @Autowired 필드 명 매칭
2. @Qualifier -> @Qualifier 끼리 매칭 -> 빈 이름 매칭
3. @Primary 사용

### @Autowired 필드 명 매칭

``` java
@Autowired
private DiscountPolicy rateDiscountPolicy
```

- 필드 명이 rateDiscountPolicy 이므로 정상 주입된다.
- 필드 명 매칭은 먼저 타입 매칭을 시도 하고 그 결과에 여러 빈이 있을 때 추가로 동작하는 기능이다.

## @Qualifier -> @Qualifier 끼리 매칭 -> 빈 이름 매칭

빈 등록시 @Qualifier를 붙여준다.

![[Pasted image 20221223165559.png]]

#### 주입시에 @Qualifier 를 붙여주고 등록한 이름을 적어준다.

### 생성자 자동 주입 예시
![[Pasted image 20221223165753.png]]

### 수정자 자동 주입 예시

![[Pasted image 20221223165809.png]]


## Primary 사용

- @Primary 가 우선순위를 정하는 방법이다. @Autowired 시에 여러 빈이 매칭되면 @Primary 가 우선권을 가진다.


## Annoration 직접 만들기


![[Pasted image 20221223182611.png]]
- 애노테이션 연관관계 애노테이션들은 가져다 붙인것.
- @Qulifier 추가

#### 사용
![[Pasted image 20221223182825.png]]

![[Pasted image 20221223182907.png]]
- 생성자 자동 주입에 사용
- 애노테이션에는 상속이라는 개념이 없다. 애노테이션을 모아서 사용하는 기능은 스프링이 지원해주는 것!
- 여러 애노테이션을 조합해서 사용할 수 있지만, 스프링이 제공하는 기능을 뚜렷한 목적 없이 무분별하게 재정의하는 것은 오히려 좋지않다.


### 조회한 빈이 모두 필요할때, List, Map


### 자동, 수동의 올바른 실무 운영

- 갈수록 자동 빈 등록을 선호하는 추세.
- 설정 정보를 기반으로 애플리케이션을 구성하는 부분과 실제 동작하는 부분을 명확하게 나누는 것이 이상적이지만, 굉장히 번거롭다 
- eg) @Component -> @Configuration 에서 @Bean을 읿력하고, 객체를 생성하고, 주입할 대상을 일일이 적어줘야함.

	#### 그럼 수동 빈 등록은 언제사용?
	- **업무 로직 빈** : 웹을 지원하는 컨트롤러, 핵심 비지니스 로직이 있는 서비스, 데이터 계층의 로직을 처리하는 리포지토리등이 모두 업무 로직이다. 보통 비지니스 요구사항을 개발할 때 추가되거나 변경
	- **기술 지원 빈** : 기술적인 문제나 공통 관심사(AOP)를 처리할 때 주로 사용된다. 데이터베이스 연결이나, 공통 로그 처리 처럼 업무 로직을 지원하기 위한 하부 기술이나 공통 기술.
	- 업무 로직은 숫자도 많고, 한번 개발해야 하면 컨트롤러, 서비스, 리포지토리 처럼 유사한 패턴이 있다. 이러한 경우 ==자동 기능을 적극 사용하는 것이 좋다.== 보통 문제가 발생하도 어떤 곳에서 문제가 발생했는지 명확하게 파악하기가 쉽다.
	- 기술 지원 로직은 업무 로직과 비교해서 그 수가 매우 적고, 애플리케이션 전반에 걸쳐서 광범위하게 영향을 미친다. 그리고 업무 로직은 문제가 발생했을 떄 어디가 문제인지 명확하게 잘 들어나지만, 기술 지원 로직은 적용이 잘 되고 있는지 아닌지 조차 파악하기 어려운 경우가 많다.. 그래서 이런 기술 지원 로직들은 가급적 ==수동 빈 등록을 사용해서 명확하게 들어내는 것이 좋다.==

### 애플리케이션에 광범위하게 영향을 미치는 기술 지원 객체는 수동 빈으로 등록해서 딱! 설정 정보에 바로 나타나게 하는 것이 유지보수 하기 좋다.
