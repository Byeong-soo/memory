너무너무 간단한 곳에서 실수해서 시간 오래 걸렸음.
pml4_set_page가 안됐었는데 밤새서 그런지 생각이 잘 안돌아가서 못찼았음
자고 와서 보니 금방 찾았음.
pml4_set_page 가 안되는걸 찾았고, pml4 값이 없다는걸 알게됨.
pml4를 넣어주는 시점이, 복사할떄나 처음 스레드가 생겨날때, spt를 선언하는 부분에서 넣어주는데 userprog를 실행하는 thread는 그 시점에 pml4를 가지고 있지 않음. load 과정에서 pml4를 넣어주므로 그때 넣어주어서 해결!

처음에 cow를 구현할때 약간 야매? 형식으로 구현했었다. cow 만 체크를 하고, 디스크에 저장하지만 프레임을 바라보고 있는 모든 페이지가 디스크에 저장하는게 아니라 한명만 저장을 했었는데 통과가 됐었다. 어제 그렇게 통과하고나서, 오늘 아침부터 바꾸기 시작해서 다음날 아침에 끝났다. 처음에 해쉬를 써보려 했는데, 이상하게 계속 동작이 안됐다. 여러 가지 이유가 있었겠지만, 해쉬를 처음 쓰는거라 해쉬에서 key값이 유니크 하지않아서 문제가 생겼었고, key 문제를 해결하니, 그다음에는 buket이 늘어나지않았다. 너무 지칠대로 지쳐 익숙한 list로 일단 구현하기로 마음 먹었다. frame 안에 page를 담는 list를 만들고 메모리가 해제될때, 프레임을 보고 있는 어떠한 페이지가 해제되더라도 모든 page들이 메모리를 해제하고 anone page는 디스크에, file page는 파일에 각각 데이터가 저장된다. 

특히 frame 테이블은 원자성이 보장 되어야하기때문에 lock이 중요하다.( 사실 단일 스레드라서 크게 문제는 없었지만, lock을 걸지않으면 fork에서 문제가 생긴다.) 비트 맵과 frame은 전역으로 사용하기 때문에 lock을 걸어주는게 좋다고 생각해서 적용했다.

cow 이론 자체는 크게 어렵지 않았다. 부모와 자식 모두가 같은 메모리를 바라보고 있고, 누군가가 메모리에 write를 하려는 순간 메모리를 할당해주면 된다. 즉 fork 에만 동작하게끔 설정하면된다. fork가 되면 cow가 켜지게 되고, 쓰려는 순간 메모리를 새로 할당 받게 된다.

아직은 반쪽자리 풀이인데 그이유가 할당을 받고나서 프레임을 보고있는 페이지가 하나만 남았을 때, cow를 안타게 하고 바로 쓰기가 가능하게 해줘야하는데 아직 구현을 못했다.

어찌됐든, 발제하기 전까지 extra? optional 까지 다한건(물론 조금 부족하지만) 처음이라 정말,,, 좋다
