## disk

- cpu와 주메모리가 메모리 버스로 연결되어 있다. 몇 가지 장치들이 범용 I/O 버스에 연결이 되어 있는데, 많은 현대의 시스템에서는 PCI(또는 다른 파생된 형태의 버스)를 사용하고 있다. SCSI나 SATA 또는 USB와 같은 주변장치용 버스가 있다.

#### 상호 동작의 과정

1. 반복적으로 장치의 상태 레지스터를 읽어서 명령의 수신 가능 여부를 확인한다. 이 동작을 장치에 대해 **폴링(plling)** 한다고 표현한다.
2. 운영체제가 데이터 레지스터에 어떤 데이터를 전달한다.
3. 운영체제가 명령 레지스터에 명령어를 기록한다.
4. 운영체제는 디바이스가 처리를 완료했는지를 확인하는 폴링 반복문을 돌면서 기다린다.

이 방식은 간단하지만 제대로 작동한다. 하지만, 매우 비효율적!
다른 프로세스에게 CPU를 양보하지않고, 장치의 동작이 완료되기 전까지 계속 루프를 돌면서 장치상태를 체크한다. 예전에 공부했던 busy-wait 방식과 유사.

- ATA
- channel
- divice disk channel secter 

copy on write 구상

- page-> frame 에 copy on write 인자? 넣어둠. count로 관리?
- count가 0 이면, 삭제 가능. count가 0 이 아니면 pml4_clear만 해주기.
- fork 할때, count 늘리는 형식.
- 부모가 먼저 죽더라도 count가 남아있다면 해제 안하고 죽도록 변경.
- 스택은 제외 시킬 것. code 영역 bss 영역 같이쓰기? mmap 도 같이쓰다가, 닫을때, 파일 수정할 때....(file은 복사가 안됨. 신경 X)
- 신경 쓸 부분은 bss 영역임. 코드 영역도 공유는 함. 하지만 쓰기가 안되고, 해제만 신경 써줄것.
- ==스레드가 종료될 때 삭제 안되게 하는게 중요.
- 3가지 책에서 처음부터 writable이 아닌 read_only로만 만들것. 그리고 쓰기 시도할떄 fault handler에서 판단할 것. 그럼 uninit 상태로 복사해서 두고 있다가, 실제로 쓰려고 하면 해제시키고 레이지 로딩 시키면 되지않을까? 그럼 anone page 를 fork 시에 writable을 false로 만들고, COW 라는걸 표시해야함. COW가 없는 프레임은 찐 read_only