이번주차는 VM 주차이다. project 1과 project2 의 경우에는 메모리가 로드 시점에 이미 다 할당을 해준다. load 시점에 쓰는 메모리나, 쓰이지 않는 메모리 모두 load 함수를 거쳐서 code 영역과 bss 영역 그리고 stack의 메모리가 할당된다.

하지만 2주차부터는 메모리를 요청할떄, 할당해주도록 한다. Lazy load 방식을 사용하는것. 처음에 가상 메모리만을 할당해주고, 실제로 userprograme이 메모리를 참조하려고 할떄 메모리를 할당해준다. lazy load 방식으로 하게 될 경우 불필요한 메모리를 줄일수 있다. 특히 cow를 구현하게 된다면, code영역이나, 쓰지않고 read만 하는 bss 영역을 공유자원으로 사용하게 되어 메모리는 한곳에만 올라가기 때문에, 많은 메모리를 아낄 수 있다.


![[Pasted image 20221213113852.png]]
- copy on write 의 예시. 쓰기 시도가 있다면 그부분의 페이지를 메모리를 할당해주고, 복사해서 그곳에 쓰게 한다.


처음에 필요한 페이지(4096 바이트)의 갯수만큼 가상주소(va)를 관리하기 위해, page 구조체를 만들어 va를 관리한다.  uninit_new 함수를 호출하여, 아직 할당 받지 않은 페이지를 생성하고, 실제로 메모리 로딩이 올라갈때, initializer 가 실행되고 type을 정해준 페이지 타입으로 변경된다.

그 후에 메모리가 부족하다면 현재 있는 메모리 중에서 evict 전략을 세워서 frame을 가져와서 메모리를 새로 할당을 해준다. 
anon 의 경우에는 swap_out 을 통해서 disk에 데이터를 쓰고, 메모리를 반환한다. 나중에 anon의 경우 swap_in을 통해 디스크에서 읽고, 할당받은 메모리에 저장한다.

file_backed의 경우 mmap 당시 받은 va주소를 저장한 페이지를 가지고 있고, swap_out 을 할 당시 메모리를 해제하는데, 현재 주소의 정보가 변경 되었다면 파일에 write로 변경해주면도, swap_in을 할때는 메모리에서 읽어오면 된다.



